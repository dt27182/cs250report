\section{Technical Approach}
\subsection{Chisel Backannotation}
\subsubsection{Why Backannotation?}
Back-annotation is a process to provide post-processing information that reflects implementation dependent characteristics to the circuit design. For Chisel designs, it is a process to provide post Chisel compilation information that is not available in the Chisel backend. 

Chisel back-annotator is developed to provide this kind of information to the the Chisel graphs in the Chisel backend, and thus, to help other tools take an advantage of the information. For example, delay information is not available until logic synthesis, but the automatic pipelining tool uses it to put pipeline registers at the optimal places. Delay information can be obtained by timing reports from Synopsys tools, and the Chisel back-annotator delivers this information to each Chisel node to help the automatic pipelining tool work on purpose. 

Another example is FPGA power modeling. To measure power efficiently, we have to generate counters for important signals that are provided by the Chisel backannotator. The power model generator produces linear power models using RTL simulations, and then the Chisel backannotator marked important signals in the Chisel graph after reading the power model. As a result, the counter generator produces counters for important signals using back-annotated Chisel graphs.

\subsubsection{Challenges}
There are several challenges for Chisel back-annotation. The first is naming problems, which occurs when the destination nodes have different names. Signal names are given during Verilog translation, a process after the elaborate process and this is highly affected by graph topology. However, the Chisel back-annotator wants to use a low-level Chisel graph which is elaborated by the backend, while other tools like the automatic pipelining tool want to manipulate a high-level Chisel graph which is only applied by part of the elaborate process. The two graphs look different from each other, which makes it difficult to match signal names between them. Thus, we define the intermediate-level Chisel graph so that both the backannotator and the tools are satisfied.


Table 1 shows the original elaborate flow and modified one for backannotation. \emph{remove type nodes} and \emph{trace nodes} are processes tools want to avoid because they change the graph undesirably. Thus, we apply processes necessary for backannotation prior to remove type nodes and trace nodes, and then obtain an intermediate-level Chisel graph. Signal names are assigned and information is backannotated to the intermediate-level graph. Tools like the automatic pipelining tool also manipulate this backannotated graph.

The second challenge is missing signals in logic synthesis. Missing signals are inevitable although we give signal preserving options to Synopsys tools. This occurs when Chisel nodes are mapped to generic logic blocks by Synopsys tools. These generic logic blocks are replaced by technology-dependent logic cells, and signals in the logics are replaced at the same time.

An approach to this problem is calculate the difference of the arrival times of two non-missing signals in a timing path, and assigning the average value to missing signals. For example, suppose we have a path starting from X through T1, T2, and T3 to Z where T1, T2, and T3 are missing signals, and the arrival times of X and Y are 0.1 and 0.4, respectively. The difference of the arrival times is 0.3.  Each missing signal is assigned 0.1 as a delay since there are three missing signals. This is a naive way to estimate delays for missing signals, but we believe this is a beginning step for delay estimation.

Another challenge is conditional statements like if and switch. These statements are converted into logic gates in logic synthesis which are not visible in Chisel graphs. Currently, we cannot directly backannotate their delays to corresponding nodes in the Chisel graphs. Instead, there is a sperate variable for those kinds of delays in reset and enable signals of registers. The Chisel backannotator uses this variable to annotate the delays of conditinal statements

\subsubsection{Delay Backannotation Flow}
