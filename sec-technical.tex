\section{Technical Approach}
Automatically finding a close-to-optimal placement of the pipeline registers takes consists of two major parts. First, we must back annotate the Chisel node graph with delay information obtained through the VLSI tools. Once we have the delay data for each Chisel node, we then use simulated annealing to place the pipeline registers based on the delay data obtained with the back annotation tool.

\subsection{Chisel Backannotation}
\begin{table*}
	\centering
	\begin{tabular} 
		{ |c | c| }
		\hline
		\textbf{Origianl backend elaborate flow} & \textbf{Backannotation backend elaborate flow} \\
		\hline \hline
		\multicolumn{2}{| c |}{{\bf -} Set the top module} \\
		\multicolumn{2}{| c |}{{\bf -} Generate muxes} \\
		\multicolumn{2}{| c |}{{\bf -} Execute pre-elaborate transforms} \\
		\multicolumn{2}{| c |}{{\bf -} Gather and sort child modules} \\
		\multicolumn{2}{| c |}{{\bf -} Assign clocks and resets} \\
		\multicolumn{2}{| c |}{{\bf -} Infer bit-widths} \\
		\hline
		{\bf -} \emph{Remove type nodes} & {\bf -} \emph{Collect nodes into components} \\ 
		\cline{2-2}
		& {\bf Intermediate-level Chisel graph} \\
		& {\bf - } \emph{Name nodes} \\
		& {\bf - } \emph{Assign signal names} \\
		& {\bf - } \emph{Backannotate delays} \\ 
		\cline{2-2}
		{\bf -} \emph{Collect nodes into components} & {\bf -} \emph{Remove type nodes} \\
		\hline
		\multicolumn{2}{| c |}{{\bf -} Execute transforms} \\
		\multicolumn{2}{| c |}{{\bf -} Trace nodes (assign bindings)} \\
		\multicolumn{2}{| c |}{{\bf -} Name nodes} \\
		\multicolumn{2}{| c |}{{\bf -} Execute analyses} \\		
		\multicolumn{2}{| c |}{{\bf -} Find combinational loops } \\
		\hline
		{\bf Verilog translation} & \\
		{\bf -} \emph{Assign signal names} & \\
		\hline
	\end{tabular}
	\caption{The original backend elaborate flow vs. The backannotation backend elaborate flow. Note that signal names are assigned to the intermediate-level Chisel graph in the backannotation backend while they are given during Verilog translation in the original backend}
	\label{backend flow}
\end{table*}

\subsubsection{Challenges}
There are several challenges for Chisel back-annotation. The first is naming problems, which occurs when the destination nodes have different names. Signal names are given during Verilog translation, a process after the elaborate process and this is highly affected by graph topology. However, the Chisel backannotator wants to use a low-level Chisel graph which is elaborated by the backend, while other tools like the automatic pipelining tool are expected to manipulate a high-level Chisel graph which is only applied by part of the elaborate process. The two graphs look different from each other, which makes it difficult to match signal names between them. Thus, we define the intermediate-level Chisel graph so that both the backannotator and the tools are satisfied.

Table \ref{backend flow} shows the original elaborate flow and modified one for backannotation. \textbf{Remove type nodes} and \textbf{Trace nodes} are processes tools want to avoid because they change the graph undesirably. Thus, we apply processes necessary for backannotation prior to \textbf{Remove type nodes} and \textbf{Trace nodes}, and then obtain an intermediate-level Chisel graph. Signal names are assigned and information is backannotated to the intermediate-level graph. Tools like the automatic pipelining tool also manipulate this backannotated graph.

The second challenge is missing signals in logic synthesis. Missing signals are inevitable although we give signal preserving options to Synopsys tools. This occurs when Chisel nodes are mapped to generic logic blocks by Synopsys tools. These generic logic blocks are replaced by technology-dependent logic cells, and signals in the logics are replaced at the same time.

An approach to this problem is calculate the difference of the arrival times of two non-missing signals in a timing path, and assigning the average value to missing signals. For example, suppose we have a path starting from X through T1, T2, and T3 to Z where T1, T2, and T3 are missing signals, and the arrival times of X and Y are 0.1 and 0.4, respectively. The difference of the arrival times is 0.3.  Each missing signal is assigned 0.1 as a delay since there are three missing signals. This is a naive way to estimate delays for missing signals, but we believe this is a beginning step for delay estimation.

Another challenge is conditional statements like if and switch. These statements are converted into logic gates in logic synthesis which are not visible in Chisel graphs. Currently, we cannot directly backannotate their delays to corresponding nodes in the Chisel graphs. Instead, there is a separate variable for those kinds of delays in reset and enable signals of registers. The Chisel backannotator uses this variable to annotate the delays of conditional statements

\subsubsection{Delay Backannotation Flow}
The Chisel backannotator marks delay information to each node in the intermediate-level Chisel graph as follows:

{\bf (1) Finds all possible timing paths}
	
The timing analysis tool finds and analyzes all of the timing paths in the design. The data is launched at the start point of a timing path by a clock edge, propagated through combinational logic in the path, and captured at the endpoint of the path by another clock edge. The startpoint of a path is a clock pin of a sequential element or and an input port of the design. The endpoint is a data input pin of a sequential logic or an output port of the design. 

The Chisel backannotator uses timing reports of timing paths to annotate Chisel graphs. It finds all possible timing paths in a Chisel graph to be reported. A timing path is given as a list of Chisel nodes where the start node represents either a register or an input port, the end node represents a register or an output port, and the intermediate nodes represent combinational logics. 

\begin{enumerate}
	\item Generate a tcl script using the timing paths
	\item Executes Design Compiler with a generated tcl script 
	\item Read timing reports from Design Compiler 
	\item Annotate the arrival time of each node
    \item Calculate or estimate each node’s delay
    \item Calculate the critical path delay
\end{enumerate}

\subsection{Automatic Pipeline Register Placement}
The automatic pipelining tool first creates a legal placement of pipeline registers based on the stage numbers of the user annotated nodes and then uses simulated annealing based on the delay data provided by the backannotation to find a close-to-optimal placement of the pipeline registers. 

\subsubsection{Pipeline Legality}
For a pipeline register placement to be legal, it must satisfy the following three conditions:

{\bf (1)} Every combinational logic node has all input signal with the same stage number.  

{\bf (2)} The stage number of every combinational logic node's output signal is greater than or equal to the maximum of its input signal stage numbers. 

{\bf (3)} There are two ways to determine the stage number of a node. One way is to trace through the node's inputs to a pipeline register and set the stage number of the node equal to the stage number of that pipeline register. Another way is to trace through the node’s consumers to a pipeline register and set the stage number of the node equal to the stage number of that pipeline register – 1. For all nodes in the graph, the stage number of the node obtained through both methods must be the same.

\subsubsection{Wire Node Insertion}
\label{wiresection}
Before the automatic pipelining tool infers the initial legal placement of the pipeline registers, it inserts Chisel Bits nodes representing wires between combinational logic nodes in the original design. This ensures that a pipeline boundary never has to fall across a combinational logic node, which would be difficult to reconcile with the notion of Pipeline Legality discussed above.
\subsubsection{Initial Placement}
The automatic pipelining tool breaks cycles in the Chisel graph by splitting architectural registers(registers present in the original one cycle design) into read and write points. The read point consists of the output of the register and the write points consist of the write data and write enables going into the register. Hence, the data sources in the Chisel node graph are read points, input nodes, and constants and the data sinks in the Chisel node are the write points and output node.

Due to reasons that will become apparent from the algorithm discussed below, in general the designer must annotate all of the data sources and data sinks in the Chisel graph in order for the automatic pipelining tool to produce a legal pipeline register placement.

The automatic pipelining tool produces the initial legal pipeline placement by propagating stage numbers out from the user annotated Chisel nodes to their inputs and consumers in a pseudo breadth-first-search (BFS) manner. When two propagation frontiers with different stage numbers meet at the same node, propagation down that path stops and pipeline registers are inserted at that node.

We must maintain the following conditions during the pipeline stage propagation process:
{\bf (1)} Adjust the propagation rates of each propagation frontier so that two different propagation frontiers never meet at a combinational logic node and always meets at a wire node mentioned in \ref{wiresection}, because it does not make sense to split a combinational logic node in half with a pipeline register.

{\bf (2)}  The stage number propagated to a combinational logic node with multiple inputs must be the maximum of the stage numbers of all of its inputs. If this was not maintained, we would have some inputs of the combinational logic node have a greater stage number than the stage number of the output of the combinational node, which violates 2nd condition of Pipeline Legality. This also means that we cannot propagate to a Chisel node with multiple inputs from the input side until all of its inputs have been propagated to.

{\bf (3)} The stage number propagated to a combinational logic node with multiple consumers must be the minimum of the stage numbers of all of its consumers. If this was not maintained, we would have some consumers of the combinational logic node have a smaller stage number than the stage number of the output of the combinational node, which cause that consumer to violate the 3rd condition of Pipeline Legality. This also means that we cannot propagate to a Chisel node with multiple consumers from the consumer side until all of its cosumers have been propagated to.

Due to conditions (2) and (3), if not all of the data sources and data sinks are user annotated, the stage propagation process may never complete.

\subsubsection{Optimizing Register Placement}
Once the tool finds an initial legal pipeline register placement, it uses simulated annealing to optimize the placement of the pipeline registers based on the delay data obtained from the Chisel backannotation.

{\bf Simulated Annealing Algorithm}.
We want a fast method of finding a close-to-optimal pipeline register placement without getting stuck at local minimums. Simulated annealing is a gradient decent like algorithm that iteratively improves upon the current solution by randomly generating neighbor solutions from the current solution and then picking the neighboring solution that decreases the cost function the most as the next solution. Unlike gradient decent, simulated annealing occasionally picks neighbor solutions that are worse than the current solution. This allows the algorithm to avoid getting stuck at local minimums. The algorithm uses the following formula to decide if it should choose a neighbor solution as the next solution:

R(0, 1) is a random number in the interval [0, 1]
At higher values of T (temperature), the algorithm is more likely to accept bad solutions. As the algorithm progresses, the value of T is lowered so that the algorithm eventually settles on a close-to-optimal solution. On each iteration, we lower T by the following formula:

This cooling schedule forces the algorithm to try many bad solutions in the very early iterations and then focus on trying good solutions for the majority of the remaining iterations. There are many possible cooling schedules, but this one has worked well for us.

The cost function used for our problem is the maximum combinational path length in the design and we obtain neighbor solutions from the current solution by moving Chisel nodes across pipeline boundaries in a way that mains a legal pipeline register placement

{\bf Finding Longest Combinational Path}.

{\bf Moving Pipeline Boundaries}.

\subsection{Tool Flow}